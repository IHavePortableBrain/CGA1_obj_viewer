using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ObjParser.Types;

namespace ObjParser
{
	public class Obj
	{
		public List<Vertex> Verticies = new List<Vertex>();
		public List<VertexTexture> Textures = new List<VertexTexture>();
		public List<VertexNormal> Normals = new List<VertexNormal>();
		public List<Face> Faces = new List<Face>();

		public Extent Size { get; set; }

		public string UseMtl { get; set; }
		public string Mtl { get; set; }

		public void Clear()
        {
			Verticies.Clear();
			Textures.Clear();
			Normals.Clear();
			Faces.Clear();
		}

        public void Load(string path)
        {
			Clear();
			Load(File.ReadAllLines(path));
        }

	    public void Load(Stream data)
	    {
            using (var reader = new StreamReader(data))
            {
                Load(reader.ReadToEnd().Split(Environment.NewLine.ToCharArray()));
            }
	    }

	    public void Load(IEnumerable<string> data)
	    {
            foreach (var line in data)
            {
                ProcessLine(line);
            }

            UpdateSize();
        }

		private void UpdateSize()
		{
            // If there are no vertices then size should be 0.
	        if (Verticies.Count == 0)
	        {
	            Size = new Extent
	            {
                    XMax = 0,
                    XMin = 0,
                    YMax = 0,
                    YMin = 0,
                    ZMax = 0,
                    ZMin = 0
	            };

	            // Avoid an exception below if VertexList was empty.
	            return;
	        }

			Size = new Extent
			{
				XMax = Verticies.Max(v => v.Vector.X),
				XMin = Verticies.Min(v => v.Vector.X),
				YMax = Verticies.Max(v => v.Vector.Y),
				YMin = Verticies.Min(v => v.Vector.Y),
				ZMax = Verticies.Max(v => v.Vector.Z),
				ZMin = Verticies.Min(v => v.Vector.Z)
			};		
		}
	
		private void ProcessLine(string line)
		{
			string[] parts = line.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

			if (parts.Length > 0)
			{
				switch (parts[0])
				{
					case "usemtl":
						UseMtl = parts[1];
						break;
					case "mtllib":
						Mtl = parts[1];
						break;
					case Vertex.Prefix:
						Vertex v = new Vertex();
						v.LoadFrom(parts);
						v.Index = Verticies.Count();
						Verticies.Add(v);
						break;
					case Face.Prefix:
						Face f = new Face();
						f.LoadFrom(parts);
						f.UseMtl = UseMtl;
						Faces.Add(f);
						break;
					case VertexTexture.Prefix:
						VertexTexture vt = new VertexTexture();
						vt.LoadFrom(parts);
						vt.Index = Textures.Count();
						Textures.Add(vt);
						break;
					case VertexNormal.Prefix:
						VertexNormal vn = new VertexNormal();
						vn.LoadFrom(parts);
						vn.Index = Normals.Count();
						Normals.Add(vn);
						break;
				}
			}
		}

		#region unobserved

		public void WriteObjFile(string path, string[] headerStrings)
		{
			using (var outStream = File.OpenWrite(path))
			using (var writer = new StreamWriter(outStream))
			{
				// Write some header data
				WriteHeader(writer, headerStrings);

				if (!string.IsNullOrEmpty(Mtl))
				{
					writer.WriteLine("mtllib " + Mtl);
				}

				Verticies.ForEach(v => writer.WriteLine(v));
				Textures.ForEach(tv => writer.WriteLine(tv));
				string lastUseMtl = "";
				foreach (Face face in Faces)
				{
					if (face.UseMtl != null && !face.UseMtl.Equals(lastUseMtl))
					{
						writer.WriteLine("usemtl " + face.UseMtl);
						lastUseMtl = face.UseMtl;
					}
					writer.WriteLine(face);
				}
			}
		}

		private void WriteHeader(StreamWriter writer, string[] headerStrings)
		{
			if (headerStrings == null || headerStrings.Length == 0)
			{
				writer.WriteLine("# Generated by ObjParser");
				return;
			}

			foreach (var line in headerStrings)
			{
				writer.WriteLine("# " + line);
			}
		}

		#endregion
	}
}
